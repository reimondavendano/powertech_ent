// src/app/services/supabase.service.ts
import { Injectable } from '@angular/core';
import { BehaviorSubject } from 'rxjs';
import { createClient, SupabaseClient, User } from '@supabase/supabase-js';
import { environment } from '../../environments/environment'; // <--- Import environment

// Define the Database interface to provide type context for Supabase
// In a real project, this would ideally be generated by the Supabase CLI (e.g., `supabase gen types typescript --schema public > types/supabase.ts`)
export interface Database {
  public: {
    Tables: {
      products: {
        Row: Product; // The type of a row in the 'products' table
        Insert: Omit<Product, 'id' | 'created_at'>; // The type of data you can insert
        Update: Partial<Omit<Product, 'id' | 'created_at'>>; // The type of data you can update
      };
      categories: {
        Row: Category;
        Insert: Omit<Category, 'id' | 'created_at'>;
        Update: Partial<Omit<Category, 'id' | 'created_at'>>;
      };
      profiles: {
        Row: {
          id: number; // Changed to number to match SQL migration
          user_id: string;
          email: string;
          role: 'user' | 'admin';
          created_at: string;
        };
        Insert: {
          id?: number; // Make optional for insert if it's auto-generated in DB
          user_id: string;
          email: string;
          role?: 'user' | 'admin';
        };
        Update: Partial<{
          id: number;
          user_id: string;
          email: string;
          role: 'user' | 'admin';
        }>;
      };
    };
    Views: {};
    Functions: {};
    Enums: {};
    CompositeTypes: {};
  };
}

export interface Category {
  id: number;
  name: string;
  description: string;
  image_url: string;
  created_at: string;
}

export interface Product {
  id: number;
  name: string;
  category_id: number; // Changed from 'category: string' to 'category_id: number'
  price: number;
  stock: number;
  description: string;
  image_url: string;
  specs: Record<string, any>; // Added specs column for flexible JSON data
  created_at: string;
  sales_count?: number;
  originalPrice?: number; // Added originalPrice as an optional property
  brand?: string; // Added for product detail view
  capacity?: string; // Added for product detail view
}

@Injectable({
  providedIn: 'root'
})
export class SupabaseService {
  // Initialize supabase directly in the constructor using environment variables
  private supabase: SupabaseClient<Database> = createClient<Database>(
    environment.supabaseUrl,
    environment.supabaseKey
  );

  private _currentUser = new BehaviorSubject<User | null>(null);
  currentUser$ = this._currentUser.asObservable();

  constructor() {
    console.log('Supabase client initialized via environment variables.');

    // Set up auth state listener
    this.supabase.auth.onAuthStateChange((event, session) => {
      this._currentUser.next(session?.user || null);
    });
  }

  get client(): SupabaseClient<Database> {
    return this.supabase;
  }

  // Supabase Authentication methods
  async signIn(email: string, password: string): Promise<{ data: { user: User | null } | null, error: any }> {
    const { data, error } = await this.client.auth.signInWithPassword({ email, password });
    if (error) {
      console.error('Supabase signIn error:', error.message);
      return { data: null, error };
    }
    return { data: { user: data.user }, error: null };
  }

  async signOut(): Promise<{ error: any }> {
    const { error } = await this.client.auth.signOut();
    if (error) {
      console.error('Supabase signOut error:', error.message);
      return { error };
    }
    return { error: null };
  }

  // Product methods
  async getProducts(): Promise<{ data: Product[] | null; error: any }> {
    const { data, error } = await this.supabase
      .from('products')
      .select('*')
      .order('created_at', { ascending: false }); // Example ordering
    return { data, error };
  }

  // New method to get a single product by ID
  async getProductById(id: number): Promise<{ data: Product | null; error: any }> {
    const { data, error } = await this.supabase
      .from('products')
      .select('*')
      .eq('id', id)
      .single(); // Use .single() to get a single object instead of an array
    return { data, error };
  }

  async getProduct(id: number): Promise<{ data: Product | null, error: any }> {
    const { data, error } = await this.client.from('products').select('*').eq('id', id).single();
    if (error) {
      console.error('Supabase getProduct error:', error.message);
      return { data: null, error };
    }
    return { data, error: null };
  }

  async createProduct(product: Omit<Product, 'id' | 'created_at'>): Promise<{ data: Product | null, error: any }> {
    const { data, error } = await this.client.from('products').insert([product]).select().single();
    if (error) {
      console.error('Supabase createProduct error:', error.message);
      return { data: null, error };
    }
    return { data, error: null };
  }

  async updateProduct(id: number, updates: Partial<Product>): Promise<{ data: Product | null, error: any }> {
    const { data, error } = await this.client.from('products').update(updates).eq('id', id).select().single();
    if (error) {
      console.error('Supabase updateProduct error:', error.message);
      return { data: null, error };
    }
    return { data, error: null };
  }

  async deleteProduct(id: number): Promise<{ error: any }> {
    const { error } = await this.client.from('products').delete().eq('id', id);
    if (error) {
      console.error('Supabase deleteProduct error:', error.message);
      return { error };
    }
    return { error: null };
  }

  // Category methods
  async getCategories(): Promise<{ data: Category[] | null; error: any }> {
    const { data, error } = await this.supabase
      .from('categories')
      .select('*')
      .order('name', { ascending: true });
    return { data, error };
  }

  async getCategoryById(id: number): Promise<{ data: Category | null; error: any }> {
    const { data, error } = await this.supabase
      .from('categories')
      .select('*')
      .eq('id', id)
      .single();
    return { data, error };
  }

  async createCategory(category: Omit<Category, 'id' | 'created_at'>): Promise<{ data: Category | null; error: any }> {
    const { data, error } = await this.client.from('categories').insert([category]).select().single();
    if (error) {
      console.error('Supabase createCategory error:', error.message);
      return { data: null, error };
    }
    return { data, error: null };
  }

  async updateCategory(id: number, updates: Partial<Category>): Promise<{ data: Category | null; error: any }> {
    const { data, error } = await this.client.from('categories').update(updates).eq('id', id).select().single();
    if (error) {
      console.error('Supabase updateCategory error:', error.message);
      return { data: null, error };
    }
    return { data, error: null };
  }

  async deleteCategory(id: number): Promise<{ error: any }> {
    const { error } = await this.client.from('categories').delete().eq('id', id);
    if (error) {
      console.error('Supabase deleteCategory error:', error.message);
      return { error };
    }
    return { error: null };
  }
}